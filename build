#!/bin/sh
export LC_ALL=C

# we only support --mode=... as the first argument of ./build
mode=
[ $# -gt 0 ] && [ "$1" != "${1#--mode=}" ] && mode="${1#--mode=}" && shift
[ "$mode" ] && [ "$mode" != build ] && [ "$mode" != config ] &&
    >&2 echo "Error: valid modes: <empty> | config | build" && exit 1
export build_mode="$mode"  # allow hooks to see this too

cd "$(dirname "$0")"
config_process_projects_cli=yes
. scripts/core-config || exit 1

hook_or_die "$config_build_pre" build-pre

[ "${PKG_CONFIG_PATH-}" ] && PKG_CONFIG_PATH=":$PKG_CONFIG_PATH"
export PKG_CONFIG_PATH="$config_local_prefix/lib/pkgconfig${PKG_CONFIG_PATH-}"

# It's impractical to parse/separate mixed configure and build arguments at the
# same invocation, so by default (both configure and build), we pass the
# additional arguments only to build - and configure only reads its values from
# ${proj}_options. If we run in mode=configure then there's no issue and
# configure does get the additional cli args.
# mode=build is required too, or else if we previously used mode=config then
# the following build will run configure again without args.
for p in $config_projects; do
    case "$build_mode" in
        config)
            highlight_msg "($config_projects) configure-only $p"
            scripts/${p}-config "$@" || err_msg_die "failed to configure '$p'"
            ;;
        build)
            highlight_msg "($config_projects) build-only $p"
            scripts/${p}-build "$@" || err_msg_die "failed to build '$p'"
            ;;
        *)
            highlight_msg "($config_projects) building $p"
            scripts/${p}-config     || err_msg_die "failed to configure '$p'"
            scripts/${p}-build "$@" || err_msg_die "failed to build '$p'"
            ;;
    esac
done

hook_or_die "$config_build_post" build-post
success_msg "built: $config_projects"
